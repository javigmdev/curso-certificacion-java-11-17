# Índice

[Curso Certificación Profesional Desarrollador Java 11 y 17
](https://www.udemy.com/course/curso-certificacion-profesional-desarrollador-java-se-11/)

**Sección 1**: Introducción

- 1. Declaración, inicialización y tipos de variables
  - 1.1. Declaración de variables
  - 1.2. Identificadores
  - 1.3. Ámbito de las variables
  - 1.4. Inicialización por defecto
  - 1.5. Variables primitivas y variables de referencia (objetos)
    - Asignación de variables primitivas y de referencia
  - 1.6. Literales
  - 1.7. Conversiones de tipos (casting)
    - Reglas de conversiones implícitas
    - Ejemplos de conversiones
- 2. Ciclo de vida de los objetos
  - 2.1. Creación de un objeto
  - 2.2. Constructores
  - 2.3. Destrucción de un objeto
- 3. Clases de envoltorio
  - 3.1. Uso
  - 3.2. Autoboxing/unboxing
  - 3.3. Inmutabilidad de objetos
- 4. Inferencia de tipos
  - 4.1. Var
- 5. Operadores Java
  - 5.1. Aritméticos
  - 5.2. Asignación
  - 5.3. Condicionales
  - 5.4. Lógicos
  - 5.5. Otros
- 6. Igualdad de objetos
  - 6.1. Operador ==
  - 6.2. Igualdad de cadenas
  - 6.3. Pool de cadenas
  - 6.4. Igualdad de objetos de envoltorio
  - 6.5. Igualdad de StringBuilder
  - 6.6. Inmutabilidad de objetos String

**Sección 2**: Estructuras de control de flujo

- 1. Operador if y ternario
  - 1.1. If
  - 1.2. Operador ternario
- 2. Switch
  - 2.1. Instrucción switch
  - 2.2. Valores de los case
  - 2.3. Bloque default
  - 2.4. Switch con valores String
- 3. For y while
  - 3.1. For
  - 3.2. Enhanced for
  - 3.3. While
- 4. Break y continue
  - 4.1. Break
  - 4.2. Continue
  - 4.3. Bucles etiquetados

**Sección 3**: Programación orientada a objetos (POO)

- 1. Creación de métodos y sobrecarga
  - 1.1. Definición y estructura
  - 1.2. Llamada a método
  - 1.3. Sobrecarga de métodos
- 2. Paso de parámetros a métodos
  - 2.1. Paso de tipos primitivos
  - 2.2. Paso de tipos objeto
  - 2.3. Paso de String
- 3. Miembros estáticos
  - 3.1. Métodos estáticos
  - 3.2. Atrubutos estáticos
  - 3.3. Bloques estáticos
- 4. Creación e inicialización de instancias
  - 4.1. Constructores
  - 4.2. Constructor por defecto
  - 4.3. Sobrecarga de constructores
  - 4.4. Llamadas a otro constructor
  - 4.5. Bloque de inicialización de instancia
- 5. Modificadores de acceso
  - 5.1. Función y tipos
  - 5.2. Public
  - 5.3. Default
  - 5.4. Private
- 6. Encapsulación
  - 6.1. Definición
- 7. Herencia
  - 7.1. Definición
  - 7.2. Herencia de Object
  - 7.3. Constructores
  - 7.4. Sobrescritura de métodos
  - 7.5. Tipo de objeto y tipo de referencia
  - 7.6. Clases abstractas y polimorfismo
  - 7.7. Interfaces
- 8. Clases anidadas
  - 8.1. Definición y tipos
  - 8.2. Clases estándares
  - 8.3. Clases estáticas
  - 8.4. Clases locales a método
  - 8.5. Clases anónimas
- 9. Enumeraciones
  - 9.1. Definición y estructura
  - 9.2. Uso en instrucciones de control
  - 9.3. Constructores
  - 9.4. Métodos de una enumeración

**Sección 4**: Colecciones

- 1. Arrays de una dimensión
  - 1.1. Definición
  - 1.2. Declaración e instancia
  - 1.3. Acceso a elementos y creación abreviada
  - 1.4. Arrays son objetos
  - 1.5. Tamaño de un array
  - 1.6. Recorrido de un array
- 2. Arrays multidimensionales
  - 2.1. Fundamentos
  - 2.2. Recorrido
  - 2.3. Arrays irregulares
  - 2.4. Creación abreviada
- 3. Genéricos
  - 3.1. Definición
  - 3.2. Tipo de genérico como dato
  - 3.3. Restricciones de tipo
  - 3.4. Métodos genéricos
- 4. Iterables y colecciones
  - 4.1. Iterables
  - 4.2. Interfaz Iterator<E>
  - 4.3. Collection
- 5. Listas
  - 5.1. Introducción
  - 5.2. Clases e interfaces
  - 5.3. Creación
  - 5.4. Principales métodos
  - 5.5. Recorrido
- 6. Mapas
  - 6.1. Características
  - 6.2. Clases e interfaces
  - 6.3. Creación
  - 6.4. Métodos HashMap
  - 6.5. Recorrido
  - 6.6. TreeMap
- 7. Conjuntos
  - 7.1. Características
  - 7.2. Clases e interfaces
  - 7.3. Creación
  - 7.4. Métodos HashSet
  - 7.5. Recorrido
- 8. Colas dobles
  - 8.1. Características
  - 8.2. Clases e interfaces
  - 8.3. Creación
  - 8.4. Métodos Deque
  - 8.5. Recorrido
- 9. Ordenación de arrays y listas
  - 9.1. Fundamentos sobre la ordenación
  - 9.2. Interfaz Comparable
  - 9.3. Ordenación de arrays
  - 9.4. Ordenación de listas
  - 9.5. Interfaz Comparator
  - 9.6. Búsqueda binaria en arrays
  - 9.7. Comparación de arrays

**Sección 5**: Modularidad

- 1. Introducción
  - 1.1. ¿Qué es un módulo?
  - 1.2. Descriptor de módulo
  - 1.3. Ventajas
- 2. Compilación y ejecución de módulos
  - 2.1. Estructura de ejemplo
  - 2.2. Compilación de un módulo
  - 2.3. Ejecución de un módulo
  - 2.4. Abreviaturas
- 3. Empaquetado de módulos
  - 3.1. Empaquetado en en archivos .jar
  - 3.2. Empaquetado en archivos .jmod
  - 3.3. Comando jdeps
- 4. Módulos anónimos y automáticos
  - 4.1. Móldulos anónimos
  - 4.2. Módulos automáticos
  - 4.3. Ejemplo
- 5. Otras características de la modularidad
  - 5.1. Exportación específica
  - 5.2. Dependencias transitivas
  - 5.3. Servicios
  - 5.4. Acceso por reflexión

**Sección 6**: Lambdas y Streams

- 1. Expresiones lambda e interfaces funcionales
  - 1.1. Interfaz funcional
  - 1.2. ¿Qué es una expresión lambda?
  - 1.3. Inferencia de tipos
  - 1.4. Comparator con lambdas
- 2. Interfaces java.util.function
  - 2.1. Introducción
  - 2.2. Interfaz Predicate
  - 2.3. Interfaz Function
  - 2.4. Interfaz Consumer
  - 2.5. Interfaz Supplier
  - 2.6. Interfaz UnaryOperator
  - 2.7. Interfaces para tipos primitivos
- 3. Streams
  - 3.1. Introducción
  - 3.2. Creación
  - 3.3. Tipos de métodos
- 4. Métodos Streams
  - 4.1. Conteo y procesado (finales)
  - 4.2. Extracción de datos (intermedios)
  - 4.3. Comprobacions (finales)
  - 4.4. Filtrado (intermedio)
  - 4.5. Búsqueda (finales)
  - 4.6. La clase Optional<T>
  - 4.7. Obtención de extremos (finales)
  - 4.8. Transformación (intermedios)
  - 4.9. Stream de tipos primitivos
  - 4.10. Transformación y aplanamiento (intermedios)
  - 4.11. Procesamiento intermedio (intermedio)
  - 4.12. Ordenación (intermedios)
  - 4.13. Reducción (final)
  - 4.14. Reducción a colección (final)
  - 4.15. Agrupación
  - 4.16. Partición
  - 4.17. Otras implementaciones de Collector
- 5. Referencias a métodos
  - 5.1. Concepto y uso
  - 5.2. Tipos y casos
- 6. Streams paralelos
  - 6.1. Fundamentos
  - 6.2. Creación
  - 6.3. Uso

**Sección 7**: Entrada-salida y BBDD

- 1. Entrada-salida java.io
  - 1.1. Salida
  - 1.2. Escritura en consola
  - 1.3. Escritura en un fichero
  - 1.4. Entrada
  - 1.5. Lectura por teclado
  - 1.6. Lectura de un fichero
  - 1.7. La clase File
- 2. Serialización
  - 2.1. Características
  - 2.2. Interfaz Serializable
  - 2.3. Escritura de objeto en un fichero
  - 2.4. Lectura de objeto de un fichero
  - 2.5. Atributos transient
- 3. Entrada-salida java.nio
  - 3.1. Paquete java.nio.files
  - 3.2. Interfaz Path
  - 3.3. Métodos de Path
  - 3.4. Lectura de un fichero con Files
  - 3.5. Escritura en ficheros con Files
  - 3.6. Otros métodos de Files
- 4. Base de datos
  - 4.1. Fundamentos JDBC
  - 4.2. API JDBC
  - 4.3. Pasos para operar contra una BD
  - 4.4. Carga del driver
  - 4.5. Establecimiento de la conexión
  - 4.6. Ejecución de consulta SQL
  - 4.7. Manipulación de resultados
  - 4.8. Cierre de la conexión

**Sección 8**: Excepciones

- 1. Excepciones y tipos
  - 1.1. Concepto
  - 1.2. Clases
  - 1.3. Clasificación
  - 1.4. Excepciones unchecked
  - 1.5. Errores
- 2. Captura de excepciones
  - 2.1. Bloques try catch
  - 2.2. Multicatch
  - 2.3. Métodos
  - 2.4. Bloque finally
- 3. Lanzamiento y propagación de excepciones
  - 3.1. Propagación
  - 3.2. Lanzamiento
- 4. Excepciones personalizadas
  - 4.1. Introducción
- 5. Try con recursos
  - 5.1. Cierre de objetos
  - 5.2. Interfaz AutoCloseable
  - 5.3. Try con recursos
  - 5.4. Cierre con try con recursos

**Sección 9**: Multitarea

- 1. Multitarea clásica
  - 1.1. Definición
  - 1.2. Implementación de tareas
  - 1.3. Extensión de la clase Thread
  - 1.4. Implementación de la interfaz Runnable
  - 1.5. Condiciones de carrera
  - 1.6. Sincronización
- 2. Nueva multitarea
  - 2.1. Clases e interfaces
  - 2.2. Interfaz ExecutorService
  - 2.3. Interfaz Callable
  - 2.4. Interfaz Future
  - 2.5. Sincronización
  - 2.6. Colecciones para concurrencia
- 3. Clases Atomic
  - 3.1. Fundamentos
  - 3.2. AtomicInteger
  - 3.3. AtomicBoolean
- 4. CyclicBarrier
  - 4.1. Concepto
  - 4.2. Creación
  - 4.3. Sincronización de los hilos
  - 4.4. Ejemplo
